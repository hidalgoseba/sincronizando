Argentina Programa

lunes, 26 de septiembre de 2022
10:37


function promedio(listaDeNumeros) {
    return sumatoria(listaDeNumeros) / longitud(listaDeNumeros);
}
function sumatoria(listaDeNumeros) {
  let sumatoria = 0;
  for (let numero of listaDeNumeros) {
    sumatoria = sumatoria + numero;
  }
  return sumatoria;
}

Desde <https://seprogramar.inti.gob.ar/inti/exercises/188-programacion-imperativa-recorridos-quien-gana-quien-pierde> 





function gananciaPositiva(balancesDeUnPeriodo){
    let suma = 0;
  for (let balance of balancesDeUnPeriodo) {
    if(balance.ganancia > 0){
      suma += balance.ganancia;
    }
  }
  return suma;
}
function promedioGananciasPositivas(balancesDeUnPeriodo){
  return gananciaPositiva(balancesDeUnPeriodo) / cantidadDeBalancesPositivos(balancesDeUnPeriodo);
}


function gananciaPromedio(balance){
 let cantidad = longitud(balance) ;
  return gananciaTotal(balance)/cantidad;

}

function cantidadDeBalancesPositivos(balancesDeUnPeriodo) {
  let cantidad = 0;
  for (let balance of balancesDeUnPeriodo) {
    if(balance.ganancia > 0){
      cantidad += 1;
    }
  }
  return cantidad;
}

module Obera
  #...más cosas que ahora no interesan...
end
module Pepita
  @energia = 100
  @ciudad = Obera
#...más cosas que ahora no interesan...
end
module Kiano1100
  #...más cosas que ahora no interesan...
end
module RolamotoC115
  #...más cosas que ahora no interesan...
end
module Enrique
  @celular = Kiano1100
  @dinero_en_billetera = 13
  @frase_favorita = 'la juventud está perdida'
end

Desde <https://seprogramar.inti.gob.ar/inti/exercises/219-programacion-con-objetos-definiendo-objetos-metodos-y-estado-cuestion-de-estado> 


estado_pepita = %w(
  energia
  ciudad 
)
  
estado_kiano1100 = %w(
  
)
  
estado_rolamotoC115 = %w(
  
) 

estado_enrique = %w(
  celular 
  dinero_en_billetera 
  frase_favorita  
)

PROGRAMACION CON OBJETOS
¡Exacto! El efecto que producen los mensajes comer_lombriz! y volar_en_circulos! es el de alterar la energía de Pepita. En concreto:
	• comer_lombriz! hace que la energia de Pepita aumente en 20 unidades;
	• volar_en_circulos! hace que la energia de Pepita disminuya en 10 unidades.
Como convención, a los mensajes con efecto (es decir, que hacen algo) les pondremos un signo de exclamación ! al final.
Veamos si se entiende: escribí un primer programa que consista en hacer que Pepita coma y vuele hasta quedarse con 150 unidades de energía. Acordate que Pepita arranca con la energía en 100.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/205-programacion-con-objetos-objetos-y-mensajes-tu-primer-programa-con-objetos> 

Pepita.comer_lombriz!
Pepita.comer_lombriz!
Pepita.comer_lombriz!
Pepita.volar_en_circulos!


Ya vimos que un objeto puede entender múltiples mensajes, y esos mensajes conforman su interfaz.
¿Pero podría haber más de un objeto que entienda los mismos mensajes?
A Pepita ya la conocemos bien: canta, come, etc. Su amiga Norita, por otro lado, no aprendió nunca a decirnos su energía. Y Mercedes es una reconocida cantora.
Usando la consola, averiguá cuál es la interfaz de cada una de ellas, y completá el listado de mensajes que cada una entiende en el editor.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/206-programacion-con-objetos-objetos-y-mensajes-quien-te-entiende> 


interfaz_pepita = %w(
  energia
  cantar!
  comer_lombriz!
  volar_en_circulos!
)
  
interfaz_norita = %w(
  cantar!
  comer_lombriz!
  volar_en_circulos!
)
  
interfaz_mercedes = %w(
  cantar!
)

Veamos si queda claro, siendo que las interfaces de Norita, Pepita y Mercedesson las siguientes:

Esto significa que comparten algunos mensajes y otros no. ¿Qué interfaces comparten entre ellas?
Completá el código en el editor.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/207-programacion-con-objetos-objetos-y-mensajes-interfaces-compartidas> 

# ¿Qué interfaz comparten Mercedes y Norita?
interfaz_compartida_entre_mercedes_y_norita = %w(
  cantar!
)

# ¿Qué interfaz comparten Pepita y Norita?
interfaz_compartida_entre_pepita_y_norita = %w(
  cantar!
  comer_lombriz!
  volar_en_circulos!
)

# ¿Qué interfaz comparten Mercedes, Norita y Pepita?
interfaz_compartida_entre_todas = %w(
  cantar!
)

Es fácil ver que en Pepita.volar_hacia! Barreal el objeto receptor es Pepita, el mensaje volar_hacia! y el argumento Barreal; pero ¿dónde queda eso de objeto y mensaje cuando hacemos, por ejemplo, 2 + 3?
Como ya dijimos, todas nuestras interacciones en un ambiente de objetos ocurren enviando mensajes y las operaciones aritméticas no son la excepción a esta regla.
En el caso de 2 + 3 podemos hacer el mismo análisis:
	• el objeto receptor es 2;
	• el mensaje es +;
	• el argumento es 3.
Y de hecho, ¡también podemos escribirlo como un envío de mensajes convencional!
Probá en la consola los siguientes envíos de mensajes:
> 5.+ 6
> 3.< 27
> Pepita.== Norita

Desde <https://seprogramar.inti.gob.ar/inti/exercises/210-programacion-con-objetos-objetos-y-mensajes-mensajes-por-todas-partes> 



En un mundo de objetos, todo lo que tenemos son objetos y mensajes. A estos últimos, podemos distinguirlos según la forma en que se escriben:
> Mensajes de palabra clave. Su nombre está compuesto por una o varias palabras, puede terminar con un signo de exclamación ! o de pregunta ?, y se envía mediante un punto. Además,
	• pueden no tomar argumentos, como Rayuela.anio_de_edicion;
	• o pueden tomar uno o más argumentos, separados por coma: SanMartin.cruzar! LosAndes, Mula.
> Operadores. Son todos aquellos cuyo "nombre" se compone de uno o más símbolos, y se envían simplemente escribiendo dichos símbolos. En cuanto a los argumentos,
	• pueden no tomar ninguno, como la negación !true;
	• o pueden tomar uno (y solo uno), como Orson == Garfield o energia + 80.
Como vimos, también se pueden escribir como mensajes de palabra clave (aunque no parece buena idea escribir 1.== 2 en vez de 1 == 2 ).
Vamos a enviar algunos mensajes para terminar de cerrar la idea. Te toca escribir un programa que haga que Pepita:
	1. Coma 90 gramos de alpiste.
	2. Vuele a Iruya.
	3. Finalmente, coma tanto alpiste como el 10% de la energía que le haya quedado.
Este programa tiene que andar sin importar con cuanta energía arranque Pepita.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/211-programacion-con-objetos-objetos-y-mensajes-recapitulando> 

Pepita.comer_alpiste! 90
Pepita.volar_hacia! Iruya
Pepita.comer_alpiste! (Pepita.energia*10/100)

Inicialmente en el ambiente solo existen objetos simples como números, strings y booleanos.
Pero como es imposible que quienes diseñan un lenguaje puedan precargar objetos para solucionar todos nuestros problemas, también nos dan la posibilidad de crear los nuestros.
En Ruby, si quisiéramos definir a Norita, escribiríamos el siguiente código:
module Norita
end
Sí, así de simple.
¿Te animás a modificar nuestro código para crear a Pepita?

Desde <https://seprogramar.inti.gob.ar/inti/exercises/212-programacion-con-objetos-definiendo-objetos-metodos-y-estado-creando-a-pepita> 


module Pepita
end

¿Otra vez undefined method? ¿Y ahora qué falta?
Para que un objeto entienda un mensaje debemos "enseñarle" cómo hacerlo, y para ello es necesario definir un método dentro de ese objeto:
module Pepita
   def self.cantar!
   end
end
Un método es, entonces, la descripción de qué hacer cuando se recibe un mensaje del mismo nombre.
Dos cosas muy importantes a tener en cuenta :
	• Todos los métodos comienzan con def y terminan con end. Si nos falta alguna de estos dos la computadora no va a entender nuestra solución.
	• Todos los métodos que pertenezcan al mismo objeto van dentro del mismo module.
Agregale a la definición de Pepita los métodos necesarios para que pueda responder a los mensajes cantar!, comer_lombriz! y volar_en_circulos!.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/214-programacion-con-objetos-definiendo-objetos-metodos-y-estado-los-mejores-los-unicos-los-metodos-en-objetos> 

module Pepita
  def self.cantar!
  end
  
  def self.comer_lombriz!
  end
  
  def self.volar_en_circulos!
  end  
end

Acabamos de aprender una de las reglas fundamentales del envío de mensajes: si a un objeto no le decímos cómo reaccionar ante un mensaje, y se lo envíamos, no lo entenderá y nuestro programa se romperá. Y la forma de hacer esto es definiendo un método.
Ahora bien, los métodos que definiste recién no eran muy interesantes: se trataba de métodos vacíos que evitaban que el programa se rompiera, pero no hacían nada. En realidad, Pepita tiene energía y los diferentes mensajes que entiende deberían modificarla.
¿Cómo podríamos decir que cuando Pepita vuela, pierde 10 unidades de energía? ¿Y que inicialmente esta energía es 100? Así:
module Pepita
  @energia = 100
def self.volar_en_circulos!
    @energia = @energia - 10
  end
end
Una vez más, ya definimos a Pepita por vos. Probá, en orden, las siguientes consultas:
> Pepita.volar_en_circulos!
> Pepita.volar_en_circulos!
> Pepita.energia
Puede que los resultados te sorprendan, en breve hablaremos de esto.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/215-programacion-con-objetos-definiendo-objetos-metodos-y-estado-perdiendo-energia> 


module Pepita
  @energia = 100
def self.volar_en_circulos!
    @energia = @energia - 10
  end
end
Decimos que Pepita conoce o tiene un nivel de energía, que es variable, e inicialmente toma el valor 100. La energía es un atributo de nuestro objeto, y la forma de asignarle un valor es escribiendo @energia = 100.
Por otro lado, cuando Pepita recibe el mensaje volar_en_circulos!, su energía disminuye: se realiza una nueva asignación del atributo y pasa a valer lo que valía antes (o sea, @energia), menos 10.
Como la operación @energia = @energia - 10 es tan común, se puede escribir @energia -= 10. Como te imaginarás, también se puede hacer con la suma.
Sabiendo esto:
	• cambiá la definición del método volar_en_circulos! para que utilice la expresión simplificada;
	• definí la versión correcta del método comer_lombriz!, que provoca que Pepita gane 20 puntos de energía;

Desde <https://seprogramar.inti.gob.ar/inti/exercises/216-programacion-con-objetos-definiendo-objetos-metodos-y-estado-atributos> 

module Pepita
    @energia = 100
  
    def self.volar_en_circulos!
        @energia -= 10
    end
  
    def self.comer_lombriz!
        @energia += 20
    end  
end

Hasta ahora los métodos que vimos solo producían un efecto. Si bien solo pueden devolver una cosa, ¡pueden producir varios efectos!
Solo tenés que poner uno debajo del otro de la siguiente forma:
def self.comprar_libro!
    @plata -= 300
    @libros += 1
end
Como te dijimos, Pepita podía volar a diferentes ciudades. Y cuando lo hace, cambia su ciudad actual, además de perder 100 unidades de energía. Las distintas ciudades vas a poder verlas en la Biblioteca.
Con esto en mente:
	• Creá un atributo ciudad en Pepita: la ciudad donde actualmente está nuestra golondrina.
	• Hacé que la ciudad inicial de pepita sea Iruya.
	• Definí un método volar_hacia! en Pepita, que tome como argumento otra ciudad y haga lo necesario.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/217-programacion-con-objetos-definiendo-objetos-metodos-y-estado-conociendo-el-pais> 

module Pepita
    @energia = 100
    @ciudad = Iruya
  
    def self.volar_en_circulos!
        @energia -= 10
    end
  
    def self.comer_lombriz!
        @energia += 20
    end  

    def self.volar_hacia!(destino)
        @energia -= 100
        @ciudad = destino
    end  
end

Antes te mostramos que si enviamos el mensaje energia, fallará:
>  Pepita.energia
undefined method `energia' for Pepita:Module (NoMethodError)
El motivo es simple: los atributos NO son mensajes.
Entonces, ¿cómo podríamos consultar la energía de Pepita? Definiendo un método, ¡por supuesto!
module Pepita
   #...atributos y métodos anteriores...
def energia
      @energia
   end
end
Ya agregamos el método energia por vos. Probá en la consola ahora las siguientes consultas:
> Pepita.energia
> Pepita.energia = 120
> energia

Desde <https://seprogramar.inti.gob.ar/inti/exercises/218-programacion-con-objetos-definiendo-objetos-metodos-y-estado-leyendo-el-estado> 

Los objetos pueden tener múltiples atributos y al conjunto de estos atributos se lo denomina estado. Por ejemplo, si miramos a Pepita:
module Pepita
  @energia = 100
  @ciudad = Obera
#...etc...
end
Lo que podemos observar es que su estado está conformado por ciudad y energia, dado que son sus atributos.
El estado es siempre privado, es decir, solo el objeto puede utilizar sus atributos, lo que explica por qué las siguiente consultas que hicimos antes fallaban:
> Pepita.energia = 100
> energia
Veamos si se entiende: mirá los objetos en la solapa Biblioteca y escribí el estado de cada uno.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/219-programacion-con-objetos-definiendo-objetos-metodos-y-estado-cuestion-de-estado> 

estado_pepita = %w(
  energia
  ciudad 
)
  
estado_kiano1100 = %w(
  
)
  
estado_rolamotoC115 = %w(
  
) 

estado_enrique = %w(
  celular 
  dinero_en_billetera 
  frase_favorita  
)

module Obera
  #...más cosas que ahora no interesan...
end
module Pepita
  @energia = 100
  @ciudad = Obera
#...más cosas que ahora no interesan...
end
module Kiano1100
  #...más cosas que ahora no interesan...
end
module RolamotoC115
  #...más cosas que ahora no interesan...
end
module Enrique
  @celular = Kiano1100
  @dinero_en_billetera = 13
  @frase_favorita = 'la juventud está perdida'
end

Desde <https://seprogramar.inti.gob.ar/inti/exercises/219-programacion-con-objetos-definiendo-objetos-metodos-y-estado-cuestion-de-estado> 


Queremos saber dónde se encuentra Pepita, para lo cual necesitamos agregarle un mensaje ciudad que nos permita acceder al atributo del mismo nombre.
Inspirándote en la definición de energia, definí el método ciudad que retorne la ubicación de nuestra golondrina.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/220-programacion-con-objetos-definiendo-objetos-metodos-y-estado-donde-estas> 

module Pepita
  @energia = 100
  @ciudad = Obera
  
  def self.energia
    @energia 
  end
  
  def self.cantar!
    'pri pri pri'
  end
  
  def self.comer_lombriz!
    @energia += 20
  end
  
  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.volar_hacia!(destino)
    @energia -= 100
    @ciudad = destino
  end
  def self.ciudad
      @ciudad
  end  
end

Volar hacia un cierto punto no es tarea tán fácil: en realidad, Pepita pierde tanta energía como la mitad de kilómetros que tenga que recorrer.
Aunque en el mapa real no sea así, imaginaremos que las ciudades están ubicadas en línea recta, para facilitar los cálculos:

Por ejemplo, si Pepita está en Obera y quiere volar a Iruya debe recorrer 670 kilómetros, por lo que perderá 335 unidades de energía.
¿Y si Pepita está en Iruya y quiere volar a Obera? ¡También! La distancia entre dos ciudades siempre es un valor positivo . Para resolver esto contamos con el mensaje abs que entienden los números y nos retorna su valor absoluto:
> 17.abs
=> 17
> (-17).abs
=> 17
> (1710 - 1040).abs
=> 670
> (1040 - 1710).abs
=> 670
> (1040 - 1710).abs / 2
=> 335
Sabiendo esto:
	• Definí el objeto que representa a BuenosAires.
	• Definí en Obera, Iruya y BuenosAires un método kilometro que retorne la altura a la que se encuentran, según el esquema. ¡Cuidado! No tenés que guardar el valor en un atributo @kilometro sino simplemente retornar el número que corresponde.
	• Modificá el método volar_hacia! de Pepita para hacer el cálculo de la distancia y alterar su energía. Para acceder al kilometro inicial de Pepita tenes que hacer @ciudad.kilometro.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/221-programacion-con-objetos-definiendo-objetos-metodos-y-estado-volando-alto> 

module Obera
  def self.kilometro
    1040.abs
  end
end

module Iruya
  def self.kilometro
    1710.abs
  end  
end

module BuenosAires
  def self.kilometro
    0.abs
  end  
end  

module Pepita
  @energia = 1000
  @ciudad = Obera
  
  def self.energia
    @energia 
  end
  
  def self.ciudad
    @ciudad
  end
  
  def self.cantar!
    'pri pri pri'
  end
  
  def self.comer_lombriz!
    @energia += 20
  end
  
  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.volar_hacia!(destino)
    @energia -= (@ciudad.kilometro - destino.kilometro).abs / 2
    @ciudad = destino
    
  end
end

En el ejercicio anterior vimos que un objeto (en ese caso, Pepita) le puede enviar mensajes a otro que conozca (en ese caso, ciudades como Obera o BuenosAires):
module Pepita
  # ...etc...
def self.volar_hacia!(destino)
    @energia -= (@ciudad.kilometro - destino.kilometro).abs / 2
    @ciudad = destino
  end
end
Esto se conoce como delegar una responsabilidad, o simplemente, delegar: la responsabilidad de saber en qué kilómetro se encuentra es de la ciudad, y no de Pepita.
A veces nos va a pasar que un objeto tiene un método muy complejo, y nos gustaría subdividirlo en problemas más chicos que el mismo objeto puede resolver. Pero, ¿cómo se envía un objeto mensajes a sí mismo?
Un objeto puede enviarse un mensaje a sí mismo fácilmente usando self como receptor del mensaje.
module Pepita
  # ...etc...
def self.volar_hacia!(destino)
    self.gastar_energia! destino #¡Ojo! No hicimos Pepita.gastar_energia!(destino)
    @ciudad = destino
  end
def self.gastar_energia!(destino)
    @energia -= (@ciudad.kilometro - destino.kilometro).abs / 2
  end
end
Pero esto se puede mejorar un poco más. Delegá el cálculo de la distancia en un método distancia_a, que tome un destino y devuelva la distancia desde la ciudad actual hasta el destino.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/222-programacion-con-objetos-definiendo-objetos-metodos-y-estado-delegar-es-bueno> 

module Pepita
  @energia = 1000
  @ciudad = Obera
  
  def self.energia
    @energia 
  end
  
  def self.ciudad
    @ciudad
  end
  
  def self.cantar!
    'pri pri pri'
  end
  
  def self.comer_lombriz!
    @energia += 20
  end
  
  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.volar_hacia!(destino)
    self.gastar_energia!(destino)
    @ciudad = destino
  end

  def self.gastar_energia!(destino)
    @energia -=  distancia_a(destino) / 2
  end
  def self.distancia_a(destino)
    (@ciudad.kilometro - destino.kilometro).abs  
  end  
end

Hay un pequeño problema conceptual con la solución anterior: ¿por qué Pepita, una golondrina, es responsable de calcular la distancia entre dos ciudades?
Dicho de otra manera, ¿es necesario contar con una golondrina para poder calcular la distancia entre dos lugares? ¿Cual es el objeto más pequeño que podría saber hacer esto?
¿Lo pensaste? La respuesta es simple: ¡la misma ciudad! Por ejemplo, BuenosAires podría entender un mensaje distancia_a, que tome otra ciudad y devuelva la distancia entre ésta y sí misma.
Modificá la solución del ejercicio anterior para que sean las ciudades las que calculan las distancias. Pensá que no solo Obera debe tener este método, sino también BuenosAires e Iruya, para cuando tenga que volve

Desde <https://seprogramar.inti.gob.ar/inti/exercises/223-programacion-con-objetos-definiendo-objetos-metodos-y-estado-es-mi-responsabilidad> 


module Obera
  def self.kilometro
    1040
  end
   def self.distancia_a(destino)
      (kilometro - destino.kilometro).abs  
   end
 
end

module Iruya
  def self.kilometro
    1710
  end 
  def self.distancia_a(destino)
      (kilometro - destino.kilometro).abs  
  end

end

module BuenosAires
  def self.kilometro
    0
  end 
  def self.distancia_a(destino)
      (kilometro - destino.kilometro).abs  
  end  
end

module Pepita
  @energia = 1000
  @ciudad = Obera
  
  def self.energia
    @energia 
  end
  
  def self.ciudad
    @ciudad
  end
  
  def self.cantar!
    'pri pri pri'
  end
  
  def self.comer_lombriz!
    @energia += 20
  end
  
  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.volar_hacia!(destino)
    self.gastar_energia!(destino)
    @ciudad = destino
  end

  def self.gastar_energia!(destino)
    @energia -= @ciudad.distancia_a(destino) / 2
  end

end

 

module Obera
    def self.kilometro
        1040
    end
def self.distancia_a(destino)
        (destino.kilometro - self.kilometro).abs
    end
end
module Iruya
  def self.kilometro
     1710
    end
def self.distancia_a(destino)
        (destino.kilometro - self.kilometro).abs
    end    
end
module BuenosAires
    def self.kilometro
        0
    end
def self.distancia_a(destino)
        (destino.kilometro - self.kilometro).abs
    end    
end
module Pepita
  @energia = 1000
def self.energia
    @energia 
  end
def self.volar_en_circulos!
    @energia -= 10
  end
def self.comer_alpiste!(gramos)
    @energia += gramos * 15
  end  
def self.debil?
    @energia < 100
  end
def self.feliz?
    @energia > 1000
  end
def self.hacer_lo_que_quiera!
    if self.debil?
      self.comer_alpiste!(10)
    end
if self.feliz?
      5.times { self.volar_en_circulos! }
    end
  end  
end

Desde <https://seprogramar.inti.gob.ar/inti/exercises/229-programacion-con-objetos-polimorfismo-y-encapsulamiento-a-entrenar> 

¿Te acordás de Pepita? Bueno, aunque no lo creas, también cambia de estados de ánimo. En nuestro modelo de Pepita, vamos a representar simplemente dos estados posibles: cuando está débil y cuando está feliz.
¿Y cuándo ocurre eso?
	• Pepita está débil si su energía es menor que 100.
	• Pepita está feliz si su energía es mayor que 1000.
Completá los métodos debil? y feliz? de Pepita.
Como en esta lección no vamos a interactuar con las ciudades, hemos quitado todo lo relacionado a ellas de Pepita. Esto solo lo hacemos para que te sea más fácil escribir el código, no lo intentes en casa.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/224-programacion-con-objetos-polimorfismo-y-encapsulamiento-pepita-esta-feliz> 

module Pepita
  @energia = 1000

  def self.energia
    @energia 
  end

  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.comer_alpiste!(gramos)
    @energia += gramos * 15
  end  

  def self.debil?
    @energia < 100
  end
  
  def self.feliz?
    @energia > 1000
  end
end

Si llegaste hasta acá, ya deberías saber que en programación existe una herramienta llamada alternativa condicional.
En Ruby, como en muchos otros lenguajes, esto se escribe con la palabra reservada if. Por ejemplo:
module Jose
  def self.acomodar_habitacion!
    self.ordenar!
    if self.tiene_sabanas_sucias?
      self.cambiar_sabanas!
    end
    self.tender_la_cama!
  end
end
Sabiendo cómo se escribe la alternativa condicional en Ruby queremos que Pepita, además de recibir órdenes, tenga sus momentos para poder hacer lo que quiera.
Obviamente, qué quiere hacer en un momento dado depende de su estado de ánimo:
	• Si está débil, come diez gramos de alpiste, para recuperarse.
	• Si no lo está, no hace nada.
Hacé que Pepita entienda el mensaje hacer_lo_que_quiera! que se comporte como explicamos.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/225-programacion-con-objetos-polimorfismo-y-encapsulamiento-reencuentro-alternativo> 

module Pepita
  @energia = 1000

  def self.energia
    @energia 
  end

  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.comer_alpiste!(gramos)
    @energia += gramos * 15
  end  

  def self.debil?
    @energia < 100
  end
  
  def self.feliz?
    @energia > 1000
  end
  
  def self.hacer_lo_que_quiera!
    if debil?
      self.comer_alpiste! 10
    end  
  end  
end

Hay veces que con un if alcanza, pero otras queremos hacer algo si no se cumple una condición. Como ya te podrás imaginar, donde hay un if ¡cerca anda un else!
module Jardinero
  def self.cuidar!(planta)
    if planta.necesita_agua?
      3.times { self.regar! planta }
    else
      self.sacar_bichos! planta
    end
  end
end
¿Y ese times qué es?
Es un mensaje que entienden los números que sirve para ejecutar una porción de código varias veces. En este caso regaríamos 3 veces la planta recibida como argumento.
Ahora que conocimos la existencia de times y vimos cómo hacer else...
Modificá la solución para que si Pepita no está débil vuele en círculos 3 veces.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/226-programacion-con-objetos-polimorfismo-y-encapsulamiento-repitamos-que-pasa-si-no> 


module Pepita
  @energia = 1000

  def self.energia
    @energia 
  end

  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.comer_alpiste!(gramos)
    @energia += gramos * 15
  end  

  def self.debil?
    @energia < 100
  end
  
  def self.feliz?
    @energia > 1000
  end
  
  def self.hacer_lo_que_quiera!
    if debil?
      self.comer_alpiste! 10
    else
      3.times { self.volar_en_circulos! }
    end  
  end  
end

Algunas veces vamos a tener condiciones anidadas. En otras palabras, un if dentro de un if o un else. Como en este ejemplo:
module Docente
  def self.nota_conceptual(nota)
    if nota > 8
      "Sobresaliente"
    else
      if nota > 6
        "Satisfactoria"
      else
        "No satisfactoria"
      end
    end
  end
end
Ahora que vimos estas condiciones anidadas que poco tienen que ver con el nido de Pepita , vamos a conocer el comportamiento definitivo de Pepita cuando hace lo que quiere:
	• Si está débil, come diez gramos de alpiste, para recuperarse.
	• Si no está debil pero sí feliz, vuela en círculos cinco veces.
	• Si no está feliz ni débil, vuela en círculos 3 veces.
Modificá a Pepita para que el método hacer_lo_que_quiera! se comporte como mencionamos más arriba.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/227-programacion-con-objetos-polimorfismo-y-encapsulamiento-voy-a-hacer-pero-como-yo-quiero> 

module Pepita
  @energia = 1000

  def self.energia
    @energia 
  end

  def self.volar_en_circulos!
    @energia -= 10
  end
  
  def self.comer_alpiste!(gramos)
    @energia += gramos * 15
  end  

  def self.debil?
    @energia < 100
  end
  
  def self.feliz?
    @energia > 1000
  end
  
  def self.hacer_lo_que_quiera!
    if debil?
      self.comer_alpiste! 10
    elsif self.feliz? 
        5.times { self.volar_en_circulos! }
    else
        3.times { self.volar_en_circulos! }
    end  
  end  
end

Pepo es un gorrión que también sabe comer, volar y hacer lo que quiera, pero lo hace de manera diferente a Pepita.
	• comer alpiste: el aparato digestivo de Pepo no anda muy bien, por eso solo puede aprovechar la mitad del alpiste que come. Por ejemplo, si come 20 gramos de alpiste, su energía solo aumenta en 10.
	• volar en círculos: gasta 15 unidades de energía si está pesado y 5 si no lo está. Decimos que está pesado si su energía es mayor a 1100.
	• hacer lo que quiera: como siempre tiene hambre, aprovecha y come 120 gramos de alpiste.
Ah, y al igual que Pepita, su energía comienza en 1000.
Definí a Pepo según las reglas anteriores. Te dejamos el código de Pepita para usar como base, modificá y borrá las partes que no correspondan.
 ¡Dame una pista!
En la Biblioteca te dejamos a Pepita por si no recordás cómo era la sintaxis de la alternativa condicional.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/228-programacion-con-objetos-polimorfismo-y-encapsulamiento-llego-pepo> 

module Pepo
  @energia = 1000
  
  def self.energia
    @energia 
  end

  def self.comer_alpiste!(gramos)
      @energia += gramos / 2 
  end
  def self.volar_en_circulos!
    if @energia > 1000
      @energia -= 15
    else 
      @energia -= 5
    end  
  end
  def self.hacer_lo_que_quiera!
    self.comer_alpiste! 120
  end  
end  

Nuestras aves quieren presentarse a las próximas Olimpíadas, y para eso necesitan ejercitar un poco.
Para ayudarnos en esta tarea conseguimos a Pachorra, un ex entrenador de fútbol que ahora se dedica a trabajar con aves. Él diseñó una rutina especial que consiste en lo siguiente:
	• Volar en círculos 10 veces.
	• Comer un puñado de 30 gramos de alpiste.
	• Volar en círculos 5 veces.
	• Como premio, que el ave haga lo que quiera.
Creá a Pachorra, el entrenador de aves, y hacé que cuando reciba el mensaje entrenar_ave! haga que Pepita realice su rutina (si, solo puede entrar a Pepita , pero lo solucionaremos pronto).
Para que no moleste, movimos el código de Pepita a la Biblioteca.
 ¡Dame una pista!
Recordá que la que entrena es Pepita, su entrenador solo le dice lo que tiene que hacer.
¡Ah! Y para que un objeto pueda mandarle mensajes a otro debe conocerlo. Por ejemplo, llamándolo por su nombre como ya hemos hecho:
Pepita.energia

Desde <https://seprogramar.inti.gob.ar/inti/exercises/229-programacion-con-objetos-polimorfismo-y-encapsulamiento-a-entrenar> 

module Pachorra
  def self.entrenar_ave!
    10.times { Pepita.volar_en_circulos! }
    Pepita.comer_alpiste! 30
    5.times { Pepita.volar_en_circulos! } 
    Pepita.hacer_lo_que_quiera! { Pepita.comer_alpiste! 10 }
  end 
  

end  

Como imaginabas, Pachorra puede entrenar cualquier tipo de aves, aunque para que no haya problemas, solo entrena de a una a la vez.
Antes de empezar a entrenar, debe firmar un contrato con el ave. Esto, por ejemplo, lo haríamos de la siguiente manera:
Pachorra.firmar_contrato! Pepita # ahora el ave de Pachorra es Pepita
Cada vez que firmamos un contrato cambiamos el ave que entrenará Pachorra, por lo cual es necesario recordar cuál es ya que a ella le enviaremos mensajes:
Pachorra.entrenar_ave! # acá entrena a Pepita
Pachorra.firmar_contrato! Pepo # ahora el ave de Pachorra es Pepo
Pachorra.entrenar_ave! # ahora entrena a Pepo
Agregale a Pachorra el método firmar_contrato!(ave), de forma tal que cuando le enviemos el mensaje entrenar_ave! haga entrenar al último ave con el que haya firmado contrato.
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module Pachorra
	2
	  
	3
	  def self.firmar_contrato!(ave)
	4
	    @ave = ave
	5
	  end
	6
	  
	7
	  def self.entrenar_ave!
	8
	    10.times { @ave.volar_en_circulos! }
	9
	    @ave.comer_alpiste! 30
	10
	    5.times { @ave.volar_en_circulos! } 
	11
	    @ave.hacer_lo_que_quiera! { @ave.comer_alpiste! 10 }
	12
	  end 
	13
	  
	14
	​
	15
	end  
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Una forma posible de cambiar el objeto al que le enviamos mensajes es modificando el valor de un atributo, como estamos haciendo en este ejemplo.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/230-programacion-con-objetos-polimorfismo-y-encapsulamiento-pachorra-todoterreno> 

¿Te acordás de Norita, la amiga de Pepita? Resulta que ella también quiere empezar a entrenar, y su código es el siguiente:
module Norita
  @energia = 500
def self.volar_en_circulos!
    @energia -= 30
  end
def self.comer_alpiste!(gramos)
    @energia -= gramos
  end  
end
Pero, ¿podrá entrenar con Pachorra?
Probalo en la consola, enviando los siguientes mensajes:
> Pachorra.firmar_contrato! Norita
> Pachorra.entrenar_ave!

Desde <https://seprogramar.inti.gob.ar/inti/exercises/231-programacion-con-objetos-polimorfismo-y-encapsulamiento-una-golondrina-diferente> 

¿Qué pasa si dos objetos, como Pepita, Norita o Pepo son capaces de responder a un mismo mensaje? Podemos intercambiar un objeto por otro sin notar la diferencia, como experimentaste recién.
Este concepto es fundamental en objetos, y lo conocemos como polimorfismo. Decimos entonces que dos objetos son polimórficos cuando pueden responder a un mismo conjunto de mensajes y hay un tercer objeto que los usa indistintamente. Dicho de otra forma, dos objetos son polimórficos para un tercer objeto cuando este puede enviarles los mismos mensajes, sin importar cómo respondan o qué otros mensajes entiendan.
En nuestro caso:
	• Pepita, Norita y Pepo son polimórficas para Emilce.
	• Pepita, Norita y Pepo no son polimórficas para Pachorra.
	• Pepita y Pepo son polimórficas para Pachorra.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/233-programacion-con-objetos-polimorfismo-y-encapsulamiento-polimorque> 


Bueno, ya entendimos que para el caso de Pachorra, Norita no es polimórfica con las otras aves, pero... ¿podremos hacer algo al respecto?
¡Claro que sí! Podemos agregarle los mensajes que le faltan, en este caso hacer_lo_que_quiera!.
¿Y qué hace Norita cuando le decimos que haga lo que quiera? Nada.
Modificá a Norita para que pueda entrenar con Pachorra.
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Norita
	2
	  @energia = 500
	3
	​
	4
	  def self.energia
	5
	    @energia
	6
	  end
	7
	​
	8
	  def self.volar_en_circulos!
	9
	    @energia -= 30
	10
	  end
	11
	  
	12
	  def self.comer_alpiste!(gramos)
	13
	    @energia -= gramos
	14
	  end  
	15
	  def self.hacer_lo_que_quiera!
	16
	    
	17
	  end  
	18
	end
	19
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Aunque parezca que no tiene mucho sentido, es común que trabajando con objetos necesitemos forzar el polimorfismo y hagamos cosas como estas.
En este caso le agregamos a Norita un mensaje que no hace nada, con el único objetivo de que sea polimórfica con sus compañeras aves.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/234-programacion-con-objetos-polimorfismo-y-encapsulamiento-forzando-el-polimorfismo> 

En los ejercicios anteriores, le habíamos incluido a Pachorra y Emilce un mensaje firmar_contrato!(ave) que modificaba su estado, es decir, alguno de sus atributos. A estos mensajes que solo modifican un atributo los conocemos con el nombre de setters, porque vienen del inglés set que significa establecer, ajustar, fijar.
Para estos casos, solemos utilizar una convención que se asemeja a la forma que se modifican los atributos desde el propio objeto, pudiendo ejecutar el siguiente código desde una consola:
Emilce.ave = Pepita
Esto se logra definiendo el método ave=, todo junto, como se ve a continuación:
module Emilce
  def self.ave=(ave_nueva)
    @ave = ave_nueva
  end
def self.entrenar_ave!
    53.times { @ave.volar_en_circulos! }
    @ave.comer_alpiste!(8)
  end
end
¿Te animás a cambiar el código de Pachorra para que siga esta convención?
	• Solución
	• Consola
	
	1
	module Pachorra
	2
	  def self.ave=(ave_nueva)
	3
	    @ave = ave_nueva
	4
	  end
	5
	  
	6
	  def self.entrenar_ave!
	7
	    10.times { @ave.volar_en_circulos! }
	8
	    @ave.comer_alpiste! 30
	9
	    5.times { @ave.volar_en_circulos! }
	10
	    @ave.hacer_lo_que_quiera!
	11
	  end
	12
	end
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Como ya te habíamos contado en una lección anterior, a estos métodos que solo sirven para acceder o modificar un atributo los llamamos métodos de acceso o accessors. Repasando, los setters son aquellos métodos que establecen el valor del atributo. Mientras que los getters son aquellos que devuelven el valor del atributo.
La convención en Ruby para estos métodos es:
	• Los setters deben llevar el mismo nombre del atributo al que están asociados, agregando un = al final.
	• Los getters usan exactamente el mismo nombre que el atributo del cual devuelven el valor pero sin el @.
	• Aquellos getters que devuelven el valor de un atributo booleano llevan ? al final.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/235-programacion-con-objetos-polimorfismo-y-encapsulamiento-empieza-el-set> 

Ya aprendiste cómo crear getters y setters para un atributo, pero ¿siempre vamos a querer ambos?
La respuesta es que no, y a medida que desarrolles más programas y dominios diferentes tendrás que construir tu propio criterio para decidir cuándo sí y cuándo no.
Por ejemplo, ¿qué pasaría si a Pepita le agregaramos un setter para la ciudad? Podríamos cambiarla en cualquier momento de nuestro programa ¡y no perdería energía! Eso va claramente en contra de las reglas de nuestro dominio, y no queremos que nuestro programa lo permita.
Te dejamos en la Biblioteca el código que modela a Manuelita, una tortuga viajera. Algunos de sus atributos pueden ser leidos, otros modificados y otros ambas cosas.
Completá las listas de atributos_con_getter y atributos_con_setter mirando en la definicion de Manuelita qué tiene programado como setter y que como getter.
 ¡Dame una pista!
Recordá la convención para nombrar los métodos de acceso que mencionamos antes:
	• Para los getters, que sirven para obtener el valor de un atributo, usamos el mismo nombre que este.
	• Para los setters, que sirven para fijar el valor de un atributo, usamos el mismo nombre que este pero con un = al final.
	• Solución
	• Biblioteca
	• Consola
	
	1
	atributos = %w(
	2
	  energia
	3
	  ciudad
	4
	  mineral_preferido
	5
	  donde_va
	6
	)
	7
	​
	8
	atributos_con_getter = %w(
	9
	  energia
	10
	  ciudad
	11
	  mineral_preferido
	12
	)
	13
	​
	14
	atributos_con_setter = %w(
	15
	  mineral_preferido
	16
	  donde_va
	17
	)
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Si hacemos bien las cosas, quien use nuestros objetos sólo verá lo que necesite para poder interactuar con ellos. A esta idea la conocemos como encapsulamiento, y es esencial para la separación de responsabilidades de la que veníamos hablando.
Será tarea tuya (y de tu equipo de trabajo, claro) decidir qué atributos exponer en cada objeto.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/236-programacion-con-objetos-polimorfismo-y-encapsulamiento-el-encapsulamiento> 

• 
• 3. Programación con Objetos
• 3. Polimorfismo y encapsulamiento
• 14. Vamos terminando
Ejercicio 14: Vamos terminando
Vamos a empezar a repasar todo lo que aprendiste en esta lección, te vamos a pedir que modeles a nuestro amigo Inodoro, un gaucho solitario de la pampa argentina. Fiel al estereotipo, Inodoro se la pasa tomando mate, y siempre lo hace con algún compinche; ya sea Eulogia, su compañera o Mendieta, su perro parlante.
Tu tarea será completar el código que te ofrecemos, definiendo los métodos incompletos y agregando los getters y setters necesarios para que sea posible:
	• Consultar cuánta cafeína en sangre tiene Inodoro.
	• Consultar al compinche de Inodoro.
	• Modificar al compinche de Inodoro.
	• Consultar si Eulogia está enojada.
	• Consultar cuántas ganas de hablar tiene Mendieta.
	• Modificar las ganas de hablar de Mendieta.
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module Inodoro
	2
	    @cafeina_en_sangre = 90
	3
	  
	4
	    def self.cafeina_en_sangre
	5
	      @cafeina_en_sangre
	6
	    end
	7
	  
	8
	    def self.compinche
	9
	     @compinche
	10
	    end
	11
	  
	12
	    def self.compinche=(nuevo_compinche)
	13
	      @compinche = nuevo_compinche
	14
	    end
	15
	 end
	16
	​
	17
	​
	18
	module Eulogia
	19
	  @enojada = false
	20
	  
	21
	  def self.enojada?
	22
	    @enojada
	23
	  end
	24
	  
	25
	end
	26
	​
	27
	module Mendieta
	28
	  @ganas_de_hablar = 5
	29
	  
	30
	  def self.ganas_de_hablar
	31
	    @ganas_de_hablar
	32
	  end  
	33
	  def self.ganas_de_hablar=(nuevo_ganas_de_hablar)
	34
	    @ganas_de_hablar = nuevo_ganas_de_hablar
	35
	  end  
	36
	end
	37
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Excelente! Parece que los getters y setters quedaron claros.
Para finalizar esta lección vamos a repasar lo que aprendimos de polimorfismo.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/237-programacion-con-objetos-polimorfismo-y-encapsulamiento-vamos-terminando> 

Para finalizar el repaso vamos a modelar el comportamiento necesario para que Inodoro pueda tomar mate con cualquiera de sus compinches... ¡Polimórficamente!
	• Cuando Inodoro toma mate aumenta en 10 su cafeína en sangre y su compinche recibe un mate.
	• Al recibir un mate, Eulogia se enoja porque Inodoro siempre le da mates fríos.
	• Por su parte, Mendieta se descompone cuando recibe un mate, porque bueno... es un perro. Esto provoca que no tenga nada de ganas de hablar (o en otras palabras, que sus ganas_de_hablar se vuelvan 0).
Definí los métodos tomar_mate!, en Inodoro, y recibir_mate! en Eulogia y Mendieta.
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module Inodoro
	2
	    @cafeina_en_sangre = 90
	3
	  
	4
	    def self.cafeina_en_sangre
	5
	      @cafeina_en_sangre
	6
	    end
	7
	  
	8
	    def self.compinche
	9
	     @compinche
	10
	    end
	11
	  
	12
	    def self.compinche=(nuevo_compinche)
	13
	      @compinche = nuevo_compinche
	14
	    end
	15
	    def self.recibir_mate!
	16
	    end  
	17
	    def self.tomar_mate!
	18
	      @cafeina_en_sangre += 10
	19
	      @compinche.recibir_mate!
	20
	    end  
	21
	 end
	22
	​
	23
	​
	24
	module Eulogia
	25
	  @enojada = false
	26
	​
	27
	  
	28
	  def self.enojada?
	29
	    @enojada
	30
	  end
	31
	  def self.recibir_mate!
	32
	    @enojada = true
	33
	  end  
	34
	end
	35
	​
	36
	module Mendieta
	37
	  @ganas_de_hablar = 5
	38
	  
	39
	  def self.ganas_de_hablar
	40
	    @ganas_de_hablar
	41
	  end  
	42
	  def self.ganas_de_hablar=(nuevo_ganas_de_hablar)
	43
	    @ganas_de_hablar = nuevo_ganas_de_hablar
	44
	  end  
	45
	  def self.recibir_mate!
	46
	    @ganas_de_hablar =  0
	47
	  end  
	48
	end
	49
	​
	50
	​
	51
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas

Desde <https://seprogramar.inti.gob.ar/inti/exercises/238-programacion-con-objetos-polimorfismo-y-encapsulamiento-se-va-la-que-falta> 

• 
• 3. Programación con Objetos
• 4. Referencias
• 1. Variables
Ejercicio 1: Variables
Hasta ahora, en objetos, un programa es simplemente una secuencia de envíos de mensajes. Por ejemplo, éste es un programa que convierte en mayúsculas al string "hola".
> "hola".upcase
=> "HOLA"
Sin embargo, podemos hacer algo más: declarar variables. Por ejemplo, podemos declarar una variable saludo, inicializarla con "hola", enviarle mensajes...
> saludo = "hola"
> saludo.upcase
=> "HOLA"
...y esperar el mismo resultado que para el programa anterior.
Veamos si queda claro: agregá al programa anterior una variable saludo_formal, inicializada con "buen día"
	• Solución
	• Consola
	
	1
	saludo = "hola"
	2
	​
	3
	saludo_formal = 'buen día'
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Momento, momento!
¿Qué sucedió aquí? Hasta ahora habíamos visto que tenemos objetos y mensajes, y sólo le podíamos enviar mensajes a los objetos, como Pepita, 14, u "hola". ¿Le acabamos de enviar un mensaje a una variable?
Sí y no. Veamos por qué...
Siguiente Ejercicio: Múltiples referencias

Desde <https://seprogramar.inti.gob.ar/inti/exercises/239-programacion-con-objetos-referencias-variables> 

Hasta ahora venimos insistiendo con que, en la programación en objetos, le enviamos mensajes a los objetos. ¡Y no mentimos!
Sucede que en realidad las cosas son un poco más complejas: no conocemos a los objetos directamente, sino a través de etiquetas llamadas referencias. Entonces cuando tenemos una declaración de variable como ésta...
saludo = "hola"
...lo que estamos haciendo es crear una referencia saludo que apunta al objeto "hola", que representamos mediante una flechita:
Y cuando tenemos...
saludo.upcase
...le estamos enviando el mensaje upcase al objeto "hola", a través de la referencia saludo, que es una variable.
Veamos si se entiende hasta acá: creá una variable llamada despedida que apunte al objeto "adiós", y luego enviale el mensaje size().
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	despedida = "adiós"
	2
	despedida.size()
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Bien! Acabás de crear este ambiente, en criollo, el lugar donde viven los objetos con los cuales podemos interactuar: 
También podemos hacer cosas como "hola".size. Allí no hay ninguna variable: ¿dónde está la referencia en ese caso? ¡Allá vamos!

Desde <https://seprogramar.inti.gob.ar/inti/exercises/240-programacion-con-objetos-referencias-las-variables-son-referencias> 

Como vemos, los objetos son las "bolitas" y las referencias, las "flechitas". Pero, ¿cuál es la diferencia entre variable y referencia?
Sucede que hay muchos tipos de referencias, y una de ellas son las variables del programa. Pero, ¿no podíamos enviarles mensajes "directamente" al objeto? Por ejemplo, ¿dónde están las referencias en estos casos?:
#¿A qué referencia el envío upcase?
"ni hao".upcase
#¿Y a qué referencia el envío size?
saludo.upcase.size
¡Simple! Cuando enviamos mensajes a objetos literales como el 2, el true u "hola", o expresiones, estamos conociendo a esos objetos a través de referencias implícitas, que son temporales (sólo existen durante ese envío de mensajes) y anónimas (no tienen un nombre asociado).
"ni hao".upcase 
        ^
        +-- Acá hay una referencia implícita al objeto "ni hao"
saludo.upcase.size
             ^
             +-- Y acá, otra referencia implícita a "HOLA"
. Las referencias explícitas son las que vimos hasta ahora. Por ejemplo:
saludoEnChino = "ni hao"
Probá las siguientes consultas en la consola y pensá en dónde hay referencias implícitas:
	• > "ni hao".upcase
	• > 4.abs.even?
	• > (4 + 8).abs
> "ni hao".upcase
=> "NI HAO"
> 4.abs.even?
=> true
>  (4 + 8).abs 

Desde <https://seprogramar.inti.gob.ar/inti/exercises/241-programacion-con-objetos-referencias-referencias-implicitas> 

Supongamos que tenemos el siguiente programa:
otro_saludo = "buen día"
despedida = otro_saludo
Como vemos, estamos asignando otro_saludo a despedida. ¿Qué significa esto? ¿Acabamos de copiar el objeto "buen día", o más bien le dimos una nueva etiqueta al mismo objeto? Dicho de otra forma: ¿apuntan ambas variables al mismo objeto?
¡Averigualo! Declará las variables otro_saludo y despedida como en el ejemplo de más arriba, y realizá las siguientes consultas utilizando equal?:
	• > "buen día".equal? "buen día"
	• > despedida.equal? "buen día"
	• > otro_saludo.equal? otro_saludo
	• > despedida.equal? otro_saludo
¡Ahora sacá tus conclusiones viendo que responde en cada caso!
> otro_saludo = "buen día"
=> "buen día"
> despedida = otro_saludo
=> "buen día"
> "buen día".equal? "buen día"
=> false
> despedida.equal? "buen día"
=> false
> otro_saludo.equal? otro_saludo
=> true

Desde <https://seprogramar.inti.gob.ar/inti/exercises/242-programacion-con-objetos-referencias-multiples-referencias> 

El mensaje equal? nos dice si dos objetos son el mismo. Veamos qué pasó con las pruebas del ejercicio anterior:
otro_saludo = "buen día" # se crea la variable otro_saludo que referencia al objeto "buen día"
despedida = otro_saludo # se crea la variable despedida que, por asignarle la referencia otro_saludo, apunta al mismo objeto
> "buen día".equal? "buen día"
=> false
> despedida.equal? "buen día"
=> false
En ambos casos el resultado fue false, dado que aquellos strings son objetos distintos, a pesar de que tengan los mismos caracteres. Cada vez que escribimos un string estamos creando un nuevo objeto. Sin embargo:
> otro_saludo.equal? otro_saludo
=> true
> despedida.equal? otro_saludo
=> true
¿Por qué? ¡Simple! Ambas referencias, otro_saludo y despedida, apuntan al mismo objeto. La moraleja es que declarar una variable significa agregar una nueva referencia al objeto existente, en lugar de copiarlo:
Distinto sería si hacemos:
otro_saludo = "buen día"
despedida = "buen día"
Lo cual da como resultado este ambiente:
Veamos otro ejemplo. Si tuvieramos el siguiente código...
persona = "Graciela"
hija_de_hector = "Graciela"
hermana_de_tito = persona
hija_de_elena = "Gracielita"
hermana_de_ana = hermana_de_tito
mama_de_gustavo = "hermana_de_ana"
tia_de_gonzalo = hija_de_hector
... podríamos decir que solo hermana_de_tito y hermana_de_ana referencian al mismo objeto que persona.
Ya entendimos que dos strings con el mismo contenido no necesariamente son el mismo objeto. Pero esto puede ser poco práctico . ¿Cómo hacemos si realmente queremos saber si dos objetos, pese a no ser el mismo, tienen el mismo estado?

Desde <https://seprogramar.inti.gob.ar/inti/exercises/243-programacion-con-objetos-referencias-identidad-revisada> 


Entonces, ¿qué pasa si lo que quiero es comparar los objetos no por su identidad, sino por que representen la misma cosa?
Pensemos un caso concreto. ¿Hay forma de saber si dos strings representan la misma secuencia de caracteres más allá de que no sean el mismo objeto? ¡Por supuesto que la hay! Y no debería sorprendernos a esta altura que se trate de otro mensaje:
> "hola" == "hola"
=> true
> "hola" == "adiós"
=> false
> "hola".equal? "hola"
=> false
El mensaje == nos permite comparar dos objetos por equivalencia; lo cual se da típicamente cuando los objetos tienen el mismo estado. Y como vemos, puede devolver true, aún cuando los dos objetos no sean el mismo.
Por ejemplo, en este caso...
procer = "San Martín"
avenida = "San Martín"
ciudad = "San Martín"
... las 3 referencias distintas apuntan a objetos equivalentes entre sí, pero no idénticos.
¡Cuidado! A diferencia de la identidad, que todos los objetos la entienden sin tener que hacer nada especial, la equivalencia es un poco más complicada.
	• Por defecto, si bien todos los objetos también la entienden, delega en la identidad, así que muchas veces es lo mismo enviar uno u otro mensaje;
	• y para que realmente compare a los objetos por su estado, vos tenés que implementar este método a mano en cada objeto que crees. Los siguientes objetos ya la implementan:
		○ Listas
		○ Números
		○ Strings
		○ Booleanos

Desde <https://seprogramar.inti.gob.ar/inti/exercises/244-programacion-con-objetos-referencias-equivalencia> 

¿Y qué hay de los objetos que veníamos definiendo hasta ahora? Por ejemplo a Fito, le aumenta la felicidad cuando come:
module Fito
  @felicidad = 100
def self.comer!(calorias)
     @felicidad += calorias * 0.001
  end
def self.felicidad
    @felicidad
  end
end
A objetos como Fito se los conocen como objetos bien conocidos: cuando los definimos no sólo describimos su comportamiento (comer!(calorias) y felicidad) y estado (@felicidad), sino que además les damos un nombre o etiqueta a través de la cual podemos conocerlos. ¿Te suena?
¡Adiviná! Esas etiquetas también son referencias . Y son globales, es decir que cualquier objeto o programa puede utilizarla.
Veamos si va quedando claro. Definí un objeto AbuelaClotilde que entienda un mensaje alimentar_nieto!, que haga comer! 2 veces a Fito: primero con 2000 calorias, y luego con 1000 calorías; ¡el postre no podía faltar! .
	• Solución
	• Consola
	
	1
	module AbuelaClotilde
	2
	​
	3
	  def self.alimentar_nieto!
	4
	    Fito.comer! 2000 
	5
	    Fito.comer! 1000 
	6
	  end  
	7
	end  
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Muchas veces, en lugar de decir que le enviamos un mensaje al objeto apuntado por la referencia Fito, podemos llegar a decir...
	enviar un mensaje a la variable Fito
...o...
	enviar un mensaje al objeto Fito
...o simplemente...
	enviar un mensaje a Fito
...porque si bien no es del todo correcto, es más breve . Lo importante es que entiendas que siempre estamos enviando el mensaje al objeto a través de una referencia.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/245-programacion-con-objetos-referencias-objetos-bien-conocidos> 

Además de los que ya vimos, hay más tipos de referencias: los atributos.
Por ejemplo, si la golondrina Pepita conoce siempre su ciudad actual...
module Pepita
  @energia = 100
def self.volar_en_circulos!
    @energia -= 10
  end
def self.ciudad=(una_ciudad)
      @ciudad = una_ciudad
  end
def self.ciudad
    @ciudad
  end
end
Y en algún momento esta pasa a ser Iruya, el diagrama de objetos será el siguiente:
Nuevamente, acá vemos otro caso de múltiples referencias: el objeto que representa a la ciudad de Iruya es globalmente conocido como Iruya, y también conocido por Pepita como ciudad.
Escribí un programa que defina la ciudad de Pepita de forma que apunte a Iruya. Y pensá: ¿cuántas referencias a Iruya hay en este programa?
	• Solución
	• Biblioteca
	• Consola
	
	1
	Pepita.ciudad = Iruya
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¿Lo pensaste?
Hay tres referencias a este objeto:
	1. La propia referencia Iruya
	2. El atributo @ciudad de Pepita
	3. una_ciudad: porque los parámetros de los métodos ¡también son referencias! Sólo que su vida es más corta: viven lo que dure la evaluación del método en el que se pasan.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/246-programacion-con-objetos-referencias-atributos-y-parametros> 

Miremos este método con más detenimiento:
def self.volar_en_circulos!
   @energia = @energia - 10
end
Lo que estamos haciendo es cambiar la energía de Pepita: pasa de su valor actual, @energia, a ese valor menos 10. Por ejemplo, pasa de 100 a 90. ¿Significa esto que el 100 se transforma en un 90 ?
No, en absoluto. @energia es una referencia a un objeto, que inicialmente apunta al objeto 100:
Luego, la operación de asignación cambia ese apuntador, que pasa a referenciar al 90:
¡Veamos si se entiende!
En este código...
module Pepita
  @energia = 100
def self.volar_en_circulos!
    @energia -= 10
  end
def self.ciudad=(una_ciudad)
    @ciudad = una_ciudad
  end
end
module Iruya
end
...si bien:
	• Pepita e Iruya son objetos bien conocidos;
	• @energiay @ciudad son atributos;
	• y una_ciudad es un parámetro;
¡Todas son referencias!

Desde <https://seprogramar.inti.gob.ar/inti/exercises/247-programacion-con-objetos-referencias-lo-100to> 

¿Te acordás de Fito? Fito también tiene un amigo, Juli. Juli es nieto de AbueloGervasio. Cuando Juli es feliz Fito es feliz:
module Fito
  def self.amigo=(un_amigo)
    @amigo = un_amigo
  end
def self.es_feliz_como_su_amigo?
    @amigo.felicidad > 105
  end
end
Creá un programa que inicialice al amigo de Fito y al nieto de AbueloGervasio de forma que ambos conozcan al mismo objeto (Juli).
Luego, hacé que el abuelo alimente a su nieto 3 veces. ¿Qué pasará con Fito? ¿Se pondrá feliz?
 ¡Dame una pista!
¡Recordá que los números entienden el mensaje times, que recibe un bloque y lo ejecuta tantas veces como el valor del número!
También recordá que para que el abuelo alimente a su nieto tenés que enviarle el mensaje alimentar_nieto!.
	• Solución
	• Consola
	
	1
	#Juli, Fito y AbueloGervasio ya están declarados.
	2
	#Inicializalos y enviales mensajes acá...
	3
	Fito.amigo = Juli
	4
	AbueloGervasio.nieto = Juli
	5
	​
	6
	​
	7
	def self.alimentar_nieto!
	8
	  
	9
	end
	10
	3.times { AbueloGervasio.alimentar_nieto! }
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
En el programa que acabás de crear, que probablemente se vea parecido a esto...
Fito.amigo = Juli
AbueloGervasio.nieto = Juli
#Si antes de alimentar al nieto preguntáramos Fito.es_feliz_como_su_amigo?, respondería false
3.times { AbueloGervasio.alimentar_nieto! }
...Juli es un objeto compartido: tanto el abuelo como su amigo lo conocen. La consecuencia de esto es que cuando su abuelo le da de comer le aumenta la felicidad, y su amigo ve los cambios: éste método que antes devolvía false, ahora devuelve true.
Y esto tiene sentido: si un objeto muta su estado, y lo expone de una u otra forma a través de mensajes, todos los que lo observen podrán ver el cambio.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/248-programacion-con-objetos-referencias-objetos-compartidos> 

Antes de terminar nos topamos con un último problema: Jor se encarga de la cocina en un restaurante de pastas y le encanta picantear! su plato del día. Sin embargo, Luchi, su ayudante, no comparte ese gusto y por suerte está ahí para suavizar! las distintas comidas del establecimiento.
	• Cada vez que Jor picantea el plato del día le agrega 5 ajíes.
	• ¡Hoy hay Fideos! Decimos que los Fideos están picantes si el plato tiene más de 2 ajíes. Inicialmente no tiene ajíes.
	• Cuando descartamos la salsa de los Fideos dejan de tener ajíes.
	• Luchi necesita saber qué plato suavizar y cuántos ajíes sacarle para hacerlo. Si el plato tiene más de 10 ajíes, directamente descarta la salsa para poder usarla en otra comida.
Definí los objetos necesarios para que podamos hacer lo siguiente:
#Configurar el plato del día de Jor
Jor.plato_del_dia = Fideos
#Que Jor le agregue picante
Jor.picantear!
#Preguntar si está picante
Fideos.picantes?
#Que Luchi suavice el plato que reciba como argumento
Luchi.suavizar! Fideos, 3
#Descartar la salsa
Fideos.descartar_la_salsa!
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module Jor
	2
	  
	3
	  def self.plato_del_dia=(un_plato)
	4
	    @plato_del_dia = un_plato
	5
	  end
	6
	  
	7
	  def self.picantear!
	8
	    @plato_del_dia.agregar_picante! 5
	9
	  end
	10
	end
	11
	​
	12
	module Fideos
	13
	  @ajies = 0
	14
	  
	15
	  def self.picantes?
	16
	    @ajies > 2
	17
	  end
	18
	  
	19
	  def self.descartar_la_salsa!
	20
	    @ajies = 0
	21
	  end
	22
	  
	23
	  def self.agregar_picante!(cant_ajies)
	24
	    @ajies += cant_ajies
	25
	  end
	26
	  
	27
	  def self.quitar_picante!(cant_ajies)
	28
	    @ajies -= cant_ajies
	29
	  end
	30
	  
	31
	  def self.ajies
	32
	    @ajies
	33
	  end
	34
	end
	35
	​
	36
	module Luchi
	37
	  
	38
	  def self.suavizar!(un_plato, cant_ajies)
	39
	    if un_plato.ajies > 10
	40
	      un_plato.descartar_la_salsa!
	41
	    else
	42
	      un_plato.quitar_picante! cant_ajies
	43
	    end
	44
	  end
	45
	end  
	46
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas

Desde <https://seprogramar.inti.gob.ar/inti/exercises/249-programacion-con-objetos-referencias-para-cerrar> 

¡Vamos a crear una biblioteca de videojuegos! Para empezar, tendremos tres videojuegos, de los cuales sabemos lo siguiente:
	• CarlosDuty: es violento. Su dificultad se calcula como 30 - @cantidad_logros * 0.5. Y si se lo juega por más de 2 horas seguidas, se le suma un logro a su cantidad. Inicialmente, el juego no tiene logros.
	• TimbaElLeon: no es violento. Su dificultad inicial es 25 y crece un punto por cada hora que se juegue.
	• Metroide: es violento sólo si @nivel_espacial es mayor a 5. Este nivel arranca en 3 pero se incrementa en 1 cada vez que se lo juega, sin importar por cuánto tiempo. Además, su dificultad siempre es 100.
Definí estos tres objetos de forma que entiendan los mensajes dificultad, violento? y jugar!(un_tiempo).
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module CarlosDuty
	2
	  # Completá aquí...
	3
	  @cantidad_logros = 0
	4
	  
	5
	  def self.violento?
	6
	    true
	7
	  end
	8
	  
	9
	  def self.dificultad
	10
	    30 - @cantidad_logros * 0.5
	11
	  end
	12
	  
	13
	  def self.jugar!(un_tiempo)
	14
	    if un_tiempo > 2
	15
	      @cantidad_logros += 1
	16
	    end
	17
	  end
	18
	end
	19
	​
	20
	module TimbaElLeon
	21
	  # Completá aquí...
	22
	  @dificultad = 25
	23
	  
	24
	  def self.violento?
	25
	    false
	26
	  end
	27
	  def self.dificultad
	28
	    @dificultad
	29
	  end
	30
	  def self.jugar!(un_tiempo)
	31
	    @dificultad += un_tiempo
	32
	  end
	33
	end
	34
	​
	35
	module Metroide
	36
	  # Completá aquí...
	37
	  @nivel_espacial = 3
	38
	​
	39
	  def self.violento?
	40
	    if @nivel_espacial > 5
	41
	      true
	42
	    end
	43
	  end
	44
	  def self.jugar!(un_tiempo)
	45
	    @nivel_espacial += un_tiempo
	46
	  end
	47
	  def self.dificultad
	48
	    100
	49
	  end
	50
	end
	51
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Ya tenemos creados los objetos para nuestra colección de videojuegos!
Es importante que notes que todos estos objetos responden a los mismos mensajes: dificultad, violento? y jugar!(un_tiempo). Como aprendiste con las golondrinas, nuestros videojuegos son polimórficos para ese conjunto de mensajes.
¡Esto significa que podemos enviarles los mismos mensajes a cualquiera de los videojuegos y usarlos indistintamente!
Siguiente Ejercicio: Creando una lista

Desde <https://seprogramar.inti.gob.ar/inti/exercises/250-programacion-con-objetos-colecciones-entrando-en-calor> 

Ejercicio 2: Creando una lista
Ahora que ya tenemos nuestros videojuegos , vamos a ordenarlos en algún lugar.
Para ello necesitamos definir un objeto, la Juegoteca, que contenga otros objetos: nuestros videojuegos. Para ello vamos a usar una lista de objetos: es un tipo de colección en la cual los elementos pueden repetirse. Es decir, el mismo objeto puede aparecer más de una vez.
Por ejemplo, la lista de números 2, 3, 3 y 9 se escribe así:
[2, 3, 3, 9]
Veamos si se entiende: definí un objeto Juegoteca que tenga un atributo juegos con su correspondiente getter. La Juegoteca tiene que tener en primer lugar el juego CarlosDuty, luego TimbaElLeon y por último Metroide.
 ¡Dame una pista!
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	end
	7
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Excelente! Ya tenemos creada la Juegoteca con algunos juegos:
¿Pero qué más podemos hacer con las colecciones? Pasemos al siguiente ejercicio...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/251-programacion-con-objetos-colecciones-creando-una-lista> 

Hasta ahora sólo vimos un tipo de colección: las listas. ¡Pero hay más!
Otro tipo muy común de colecciones son los sets (conjuntos), los cuales tienen algunas diferencias con las listas:
	• no admiten elementos repetidos;
	• sus elementos no tienen un orden determinado.
Vamos a ver un ejemplo transforma una lista en un set utilizando to_set:
> numeros_aleatorios = [1,27,8,7,8,27,87,1]
> numeros_aleatorios
=> [1,27,8,7,8,27,87,1]
> numeros_aleatorios.to_set
=> #<Set: {1, 27, 8, 7, 87}>
Algo importante a tener en cuenta es que tanto las listas como los sets tienen mensajes en común. Dicho de otro modo, son polimórficos para algunos mensajes. Por ejemplo: push, delete, include? y size.
Sin embargo, los siguientes mensajes...
numeros_de_la_suerte = [6, 7, 42]
numeros_de_la_suerte.first
  # Nos retorna el primer elemento de la lista
numeros_de_la_suerte.last
  # Nos retorna el último de la lista
numeros_de_la_suerte.index 7
  # Nos retorna la posición de un elemento en la lista
... no podemos enviárselos a un set porque sus elementos no están ordenados.
Pero no te preocupes, todos lo que veamos de ahora en adelante en esta lección funciona tanto para listas como para sets.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/253-programacion-con-objetos-colecciones-set-o-no-set> 

• 
• 3. Programación con Objetos
• 5. Colecciones
• 3. Algunos mensajes básicos
Ejercicio 3: Algunos mensajes básicos
¡Tengo una colección! ¿Y ahora qué...?
Todas las colecciones entienden una serie de mensajes que representan operaciones o consultas básicas sobre la colección.
Por ejemplo, podemos agregar un elemento enviándole push a la colección o quitarlo enviándole delete:
numeros_de_la_suerte = [6, 7, 42]
numeros_de_la_suerte.push 9
  # Agrega el 9 a la lista...
numeros_de_la_suerte.delete 7
  # ...y quita el 7.
También podemos saber saber si un elemento está en la colección usando include?:
numeros_de_la_suerte.include? 6
  # Devuelve true, porque contiene al 6...
numeros_de_la_suerte.include? 8
  # ...devuelve false, porque no contiene al 8.
Finalmente, podemos saber la cantidad de elementos que tiene enviando size:
numeros_de_la_suerte.size
  # Devuelve 3, porque contiene al 6, 42 y 9
¡Probá enviarle los mensajes push, delete, include? y size a la colección numeros_de_la_suerte!
 ¡Dame una pista!
Recordá que, además de los mensajes que vimos recién, podés enviar simplemente numeros_de_la_suerte en la consola para ver qué elementos componen a la colección.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/252-programacion-con-objetos-colecciones-algunos-mensajes-basicos> 


Primero nos encargamos de los videojuegos, y ahora ya conocés qué mensajes entienden las listas. ¡Es momento de darle funcionalidad a la Juegoteca!
Nuestra Juegoteca maneja puntos. Agregá el código necesario para que entienda los siguientes mensajes:
	• puntos: nos dice cuantos puntos tiene la Juegoteca. Inicialmente son 0.
	• adquirir_juego!(un_juego): agrega el juego a la Juegoteca, y le suma 150 puntos.
	• borrar_juego!(un_juego): quita un juego de la Juegoteca, pero no resta puntos.
	• completa?: se cumple si la Juegoteca tiene más de 1000 puntos y más de 5 juegos.
	• juego_recomendable?(un_juego): es verdadero para un_juego si no está en la Juegoteca y es violento?.
 ¡Dame una pista!
	• Solución
	• Consola
	
	1
	module Juegoteca
	2
	  @puntos = 0
	3
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	4
	  def self.juegos
	5
	    @juegos
	6
	  end
	7
	  def self.puntos
	8
	    @puntos
	9
	  end
	10
	  def self.adquirir_juego!(un_juego)
	11
	    @juegos.push un_juego
	12
	    @puntos += 150
	13
	  end
	14
	  def self.borrar_juego!(un_juego)
	15
	    @juegos.delete un_juego
	16
	  end
	17
	  def self.completa?
	18
	    @puntos > 1000 && @juegos.size > 5
	19
	  end
	20
	  def self.juego_recomendable?(un_juego)
	21
	    !(@juegos.include? un_juego) && (un_juego.violento?)
	22
	  end
	23
	end
	24
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Hay una diferencia notable entre los primeros dos mensajes (push y delete) y los otros dos (include? y size):
	1. push y delete, al ser evaluados, modifican la colección. Dicho de otra forma, producen un efecto sobre la lista en sí: agregan o quitan un elemento del conjunto.
	2. include? y size sólo nos retornan información sobre la colección. Son métodos sin efecto.
Ahora que ya dominás las listas, es el turno de subir un nivel más...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/254-programacion-con-objetos-colecciones-mejorando-la-juegoteca> 

Ejercicio 6: ¿Bloques? ¿Eso se come?
¡Pausa! Antes de continuar, necesitamos conocer a unos nuevos amigos: los bloques.
Los bloques son objetos que representan un mensaje o una secuencia de envíos de mensajes, sin ejecutar, lista para ser evaluada cuando corresponda. La palabra con la que se definen los bloques en Ruby es proc. Por ejemplo, en este caso le asignamos un bloque a incrementador:
un_numero = 7
incrementador = proc { un_numero = un_numero + 1 }
Ahora avancemos un pasito: en este segundo ejemplo, al bloque { otro_numero = otro_numero * 2 } le enviamos el mensaje call, que le indica que evalúe la secuencia de envíos de mensajes dentro de él.
otro_numero = 5
duplicador = proc { otro_numero = otro_numero * 2 }.call
¿Cuánto vale un_numero luego de las primeras dos líneas? Tené en cuenta que la secuencia de envío de mensajes en el bloque del primer ejemplo está sin ejecutar. En cambio, en el ejmplo de otro_numero estamos enviando el mensaje call. Por lo tanto:
	• un_numero vale 7, porque el bloque incrementador no está aplicado. Por tanto, no se le suma 1.
	• otro_numero vale 10, porque el bloque duplicador se aplica mediante el envío de mensaje call, que hace que se ejecute el código dentro del bloque. Por tanto, se duplica su valor.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/255-programacion-con-objetos-colecciones-bloques-eso-se-come> 

Los bloques también pueden recibir argumentos para su aplicación. Por ejemplo, sumar_a_otros_dos recibe dos argumentos, escritos entre barras verticales | y separados por comas:
un_numero = 3
sumar_a_otros_dos = proc { |un_sumando, otro_sumando| un_numero = un_numero + un_sumando + otro_sumando }
Para aplicar el bloque sumar_a_otros_dos, se le pasan los argumentos deseados al mensaje call:
> sumar_a_otros_dos.call(1,2)
=> 6
Volvamos a los videojuegos...
En la Biblioteca podés ver el objeto TimbaElLeon. Para resolver este ejercicio, no nos interesa cómo están definidos los métodos de este objeto, solo queremos recordar los mensajes que entiende ¡por eso hay puntos suspensivos!
Asignale a la variable jugar_a_timba un bloque que reciba un único parámetro. El bloque recibe una cantidad de minutos y debe hacer que se juegue a TimbaElLeon durante ese tiempo, pero recordá que jugar! espera una cantidad de horas.
 ¡Dame una pista!
	• Solución
	• Biblioteca
	• Consola
	1
	jugar_a_timba = proc { |minutos| TimbaElLeon.jugar!(minutos/60) }
	2
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Quizá estés pensando, ¿qué tiene que ver todo esto con las colecciones? ¡Paciencia! En el siguiente ejercicio veremos cómo combinar colecciones y bloques para poder enviar mensajes más complejos.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/256-programacion-con-objetos-colecciones-bloques-con-parametros> 

¿Qué pasa cuando queremos todos aquellos objetos que cumplan con una condición determinada en una cierta colección? Por ejemplo, si de una lista de números queremos los mayores a 3.
Lo que usamos es el mensaje select de las colecciones. select recibe un bloque con un parámetro que representa un elemento de la colección y una condición booleana como código, y lo que devuelve es una nueva colección con los elementos que la cumplen.
algunos_numeros = [1, 2, 3, 4, 5]
mayores_a_3 = algunos_numeros.select { |un_numero| un_numero > 3 }
¿Y cuándo se aplica ese bloque que recibe el select? ¡El select es quien decide! La colección va a aplicarlo con cada uno de los objetos (un_numero) cuando corresponda durante el seleccionado (o filtrado) de elementos.
> mayores_a_3
=> [4, 5]
Mientras tanto, en nuestra juegoteca...
¡Ahora te toca a vos! Definí el método juegos_violentos que retorna los juegos de la Juegoteca que cumplan violento?.
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.juegos_violentos
	7
	    juegos_violentos = @juegos.select {|juego| juego.violento?}
	8
	  end
	9
	end
	10
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¿Y qué pasa con la colección original, como algunos_numeros o juegos? ¿Se modifica al aplicar select?
¡No, para nada! El select no produce efecto.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/257-programacion-con-objetos-colecciones-filtrando-quienes-cumplen> 

¿Y si en vez de todos los elementos que cumplan una condición, sólo queremos uno? ¡Usamos find!
algunos_numeros = [1, 2, 3, 4, 5]
uno_mayor_a_3 = algunos_numeros.find { |un_numero| un_numero > 3 }
Mientras que select devuelve una colección, find devuelve únicamente un elemento.
> uno_mayor_a_3
=> 4
¿Y si ningún elemento de la colección cumple la condición? Devuelve nil, que, como aprendiste antes, es un objeto que representa la nada - o en este caso, que ninguno cumple la condición.
Veamos si se entiende: hacé que la Juegoteca entienda juego_mas_dificil_que(una_dificultad), que retorna algún juego en la Juegoteca con más dificultad que la que se pasa como argumento.
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.juego_mas_dificil_que(una_dificultad)
	7
	    @juegos.find {|juego| juego.dificultad > una_dificultad}
	8
	  end
	9
	end
	10
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Un dato curioso para tener en cuenta: ¡los mensajes find y detect hacen exactamente lo mismo!
Siguiente Ejercicio: ¿Alguno cumple? ¿Todos cumplen?

Desde <https://seprogramar.inti.gob.ar/inti/exercises/258-programacion-con-objetos-colecciones-el-que-busca-encuentra> 

Para saber si todos los elementos de una colección cumplen un cierto criterio podemos usar el mensaje all?, que también recibe un bloque. Por ejemplo, si tenemos una colección de estudiantes, podemos saber si todo el grupo aprueba de la siguiente forma:
estudiantes.all? { |un_estudiante| un_estudiante.aprobo? }
De manera muy similar podemos saber si algún elemento de la colección cumple cierta condición mediante el mensaje any?. Siguiendo el ejemplo anterior, ahora queremos saber si por lo menos alguien aprobó :
estudiantes.any? { |un_estudiante| un_estudiante.aprobo? }
Definí los siguientes métodos en nuestra Juegoteca:
	• mucha_violencia?: se cumple si todos los juegos que posee son violentos.
	• muy_dificil?: nos dice si alguno de los juegos tiene más de 25 puntos de dificultad.
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.mucha_violencia?
	7
	    @juegos.all? {|juegos| juegos.violento?}
	8
	  end
	9
	  def self.muy_dificil?
	10
	    @juegos.any? {|juegos| juegos.dificultad > 25}
	11
	  end
	12
	end
	13
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¿Qué tienen de distinto all? y any? respecto aselect y find?
Mientras que select devuelve una colección y find un elemento o nil, all? y any? siempre devuelven un valor booleano: true o false.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/259-programacion-con-objetos-colecciones-alguno-cumple-todos-cumplen> 


El mensaje map nos permite, a partir de una colección, obtener otra colección con cada uno de los resultados que retorna un envío de mensaje a cada elemento.
En otras palabras, la nueva colección tendrá lo que devuelve el mensaje que se le envíe a cada uno de los elementos. Por ejemplo, si usamos map para saber los niveles de energía de una colección de golondrinas:
> [Pepita, Norita].map { |una_golondrina| una_golondrina.energia }
=> [77, 52]
Al igual que el resto de los mensajes que vimos hasta ahora, map no modifica la colección original ni sus elementos, sino que devuelve una nueva colección.
Agregá a la Juegoteca un método llamado dificultad_violenta que retorne una colección con la dificultad de sus juegos_violentos.
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.juegos_violentos
	7
	    juegos_violentos = @juegos.select {|juego| juego.violento?}
	8
	  end
	9
	  def self.dificultad_violenta
	10
	    juegos_violentos.map {|juego| juego.dificultad}
	11
	  end
	12
	end
	13
	​
	14
	​
	15
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Antes de seguir, un caso particular. Dijimos que map no modifica la colección original. Pero, ¿qué ocurriría si el mensaje dentro del bloque en el map sí tiene efecto?
En ese caso se modificaría la colección original, pero sería un mal uso del map . Lo que nos interesa al mapear es lo que devuelve el mensaje que enviamos, no provocar un efecto sobre los objetos.

Desde <https://seprogramar.inti.gob.ar/inti/exercises/260-programacion-con-objetos-colecciones-el-viejo-y-querido-map> 

Volviendo a nuestra colección de estudiantes. Ya preguntamos si todo el grupo aprobó o si al menos alguien aprobó utilizando all?y any?. ¿Y si queremos saber cuántos aprobaron? Usamos count:
estudiantes.count { |un_estudiante| un_estudiante.aprobo? }
count nos dice cuántos elementos de una colección cumplen la condición. Por otro lado, para calcular sumatorias tenemos el mensaje sum. Si queremos conocer la suma de todas las notas de la colección de estuidantes, por ejemplo, podemos hacer:
estudiantes.sum { |un_estudiante| un_estudiante.nota_en_examen }
Veamos si se entiende: agregá a la Juegoteca el método promedio_de_violencia, cuyo valor sea la sumatoria de dificultad de los juegos violentos dividida por la cantidad de juegos violentos de la Juegoteca.
 ¡Dame una pista!
¡Atención a la división en promedio_de_violencia! Te recomendamos pensarlo en dos partes:
	• Primero, necesitás la sumatoria de la dificultad de los juegos violentos.
	• A ese valor, lo dividís por la cantidad de juegos violentos.
¡Recordá que podés partir un problema delegando en varios mensajes!
	• Solución
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.juegos_violentos
	7
	    juegos_violentos = @juegos.select {|juego| juego.violento?}
	8
	  end
	9
	  def self.promedio_de_violencia
	10
	    (juegos_violentos.sum {|juego| juego.dificultad})/ (juegos_violentos.count {|juego| juego.violento?})
	11
	  end
	12
	end
	13
	​
	14
	​
	15
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas

Desde <https://seprogramar.inti.gob.ar/inti/exercises/261-programacion-con-objetos-colecciones-cuantos-cumplen-cuanto-suman> 

Hasta ahora, todos los mensajes que vimos de colecciones (con la excepción de push y delete) no están pensados para producir efectos sobre el sistema. ¿Qué ocurre, entonces, cuando queremos hacer algo con cada elemento? A diferencia del map, no nos interesan los resultados de enviar el mismo mensaje a cada objeto, sino mandarle un mensaje a cada uno con la intención de producir un efecto.
Es en este caso que nos resulta de utilidad el mensaje each.
Por ejemplo, si queremos que de una colección de golondrinas, aquellas con energía mayor a 100 vuelen a Iruya, podríamos combinar select y each para hacer:
golondrinas
  .select { |una_golondrina| una_golondrina.energia > 100 }
  .each { |una_golondrina| una_golondrina.volar_hacia! Iruya }
Ya que casi terminamos la guía y aprovechando que tenemos una colección de videojuegos, lo que queremos es... ¡jugar a todos!
Definí el método jugar_a_todo! en la Juegoteca, que haga jugar a cada uno de los juegos durante 5 horas. Recordá que los juegos entienden jugar!(un_tiempo).
	• Solución
	• Biblioteca
	• Consola
	
	1
	module Juegoteca
	2
	  @juegos = [CarlosDuty, TimbaElLeon, Metroide]
	3
	  def self.juegos
	4
	    @juegos
	5
	  end
	6
	  def self.jugar_a_todo!
	7
	    @juegos.each {|juego| juego.jugar!(5)}
	8
	  end
	9
	end
	10
	​
	11
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas

Desde <https://seprogramar.inti.gob.ar/inti/exercises/262-programacion-con-objetos-colecciones-jugando-a-todo> 

¡Te damos la bienvenida a la invasión zombi!
Vamos a crear al primero de nuestros zombis: Bouba. Bouba no sabe correr, porque es un simple caminante , y cuando le pedimos que grite, responde "¡agrrrg!". Además sabe decirnos su salud, que inicialmente es 100, pero puede cambiar.
¿Cuándo cambia? Al recibir_danio!: cuando lo atacan con ciertos puntos de daño, su salud disminuye el doble de esa cantidad.
Manos a la obra: creá el objeto Bouba, que debe entender los mensajes sabe_correr?, gritar, salud y recibir_danio!.
¡Cuidado! La salud de Bouba no puede ser menor que cero.
 ¡Dame una pista!
¡Recordá que las colecciones entienden el mensaje max! En el caso de una colección de números, devuelve el más alto:
> [-5, 7].max
=> 7
	• Solución
	• Consola
	
	1
	module Bouba
	2
	  
	3
	  @salud = 100
	4
	  def self.sabe_correr?
	5
	    false
	6
	  end
	7
	  
	8
	  def self.gritar
	9
	    "¡agrrrg!"
	10
	  end
	11
	  
	12
	  def self.salud
	13
	    @salud
	14
	  end
	15
	  
	16
	  def self.recibir_danio!(puntos)
	17
	    @salud -= puntos * 2
	18
	    if @salud < 0
	19
	      @salud = 0
	20
	    end
	21
	​
	22
	    
	23
	  end
	24
	  
	25
	end
	26
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¡Bien! La salud de nuestro zombi Bouba disminuye cuando recibe daño. ¡Pero aún no hay nadie que lo pueda atacar! Acompañanos...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/263-programacion-con-objetos-clases-e-instancias-zombi-caminante> 


Te presentamos a la primera de las sobrevivientes de la invasión, Juliana . Por ahora su comportamiento es simple: sabe atacar! a un zombi con cierta cantidad de puntos de daño. Y al hacerlo, el zombi recibe daño.
Además cuenta con un nivel de energia, que inicia en 1000, pero todavía no haremos nada con él. Definí un método getter para este atributo.
Veamos si se entiende: definí el objeto Juliana que pueda atacar! a un zombi haciéndolo recibir_danio!, e inicializá su energía en 1000.
 ¡Dame una pista!
¿Qué dos cosas tiene que saber Juliana para poder atacar!? ¡A quién y con cuántos puntos de daño!
	• Solución
	• Consola
	
	1
	module Juliana
	2
	  @energia = 1000
	3
	  def self.energia
	4
	    @energia
	5
	  end
	6
	  def self.atacar!(zombi, puntos)
	7
	    zombi.recibir_danio!(puntos)
	8
	  end
	9
	end
	10
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Ahora que Juliana sabe atacar!, veamos contra quién más se puede enfrentar...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/264-programacion-con-objetos-clases-e-instancias-atacando-un-zombi> 

¡Bouba no está solo! Resulta que tiene un amigo, Kiki. Podríamos decir que los dos son tal para cual: ¡el comportamiento de ambos es exactamente el mismo! Es decir, no sabe_correr?, grita "¡agrrrg!", recibe daño de la misma forma...
Definí otro objeto, Kiki, que se comporte de la misma forma que Bouba. ¡Te dejamos a Bouba para que lo uses como inspiración!
	• Solución
	• Consola
	
	1
	module Bouba
	2
	  
	3
	  @salud = 100
	4
	  def self.sabe_correr?
	5
	    false
	6
	  end
	7
	  
	8
	  def self.gritar
	9
	    "¡agrrrg!"
	10
	  end
	11
	  
	12
	  def self.salud
	13
	    @salud
	14
	  end
	15
	  
	16
	  def self.recibir_danio!(puntos)
	17
	    @salud -= puntos * 2
	18
	    if @salud < 0
	19
	      @salud = 0
	20
	    end
	21
	​
	22
	    
	23
	  end
	24
	  
	25
	end
	26
	module Kiki
	27
	  
	28
	  @salud = 100
	29
	  def self.sabe_correr?
	30
	    false
	31
	  end
	32
	  
	33
	  def self.gritar
	34
	    "¡agrrrg!"
	35
	  end
	36
	  
	37
	  def self.salud
	38
	    @salud
	39
	  end
	40
	  
	41
	  def self.recibir_danio!(puntos)
	42
	    @salud -= puntos * 2
	43
	    if @salud < 0
	44
	      @salud = 0
	45
	    end
	46
	​
	47
	    
	48
	  end
	49
	  
	50
	end
	51
	​
	52
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
¿Qué pasó acá? Tenemos dos objetos de comportamiento idéntico, cuya única diferencia es la referencia con la que los conocemos: uno es Bouba, el otro es Kiki. ¡Pero estamos repitiendo lógica en el comportamiento de ambos objetos!

Desde <https://seprogramar.inti.gob.ar/inti/exercises/265-programacion-con-objetos-clases-e-instancias-otro-zombi-caminante> 

¿Acaso Bouba y Kiki pensaron que eran invencibles? Cuando su salud llega a 0, su vida termina... nuevamente. ¡Son zombis, después de todo!
Definí el método sin_vida? que nos dice si la salud de Bouba o Kiki es cero.
	• Solución
	• Consola
	
	1
	module Bouba
	2
	  
	3
	  @salud = 100
	4
	  def self.sabe_correr?
	5
	    false
	6
	  end
	7
	  
	8
	  def self.gritar
	9
	    "¡agrrrg!"
	10
	  end
	11
	  
	12
	  def self.salud
	13
	    @salud
	14
	  end
	15
	  
	16
	  def self.recibir_danio!(puntos)
	17
	    @salud -= puntos * 2
	18
	    if @salud < 0
	19
	      @salud = 0
	20
	    end 
	21
	  end
	22
	  
	23
	  def self.sin_vida?
	24
	    @salud == 0
	25
	  end
	26
	end
	27
	module Kiki
	28
	  
	29
	  @salud = 100
	30
	  def self.sabe_correr?
	31
	    false
	32
	  end
	33
	  
	34
	  def self.gritar
	35
	    "¡agrrrg!"
	36
	  end
	37
	  
	38
	  def self.salud
	39
	    @salud
	40
	  end
	41
	  
	42
	  def self.recibir_danio!(puntos)
	43
	    @salud -= puntos * 2
	44
	    if @salud < 0
	45
	      @salud = 0
	46
	    end
	47
	  end
	48
	  def self.sin_vida?
	49
	    @salud == 0
	50
	  end
	51
	end
	52
	​
	53
	​
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Al igual que nos pasó con el resto de los mensajes, sin_vida? es exactamente igual para ambos zombis. ¡Otra vez hubo que escribir todo dos veces!
Ahora ya es imposible no verlo: todo lo que se modifique en un zombi también se modifica en el otro. ¿Qué problemas nos trae esto?
	• Aunque nos equivoquemos en una cosa, el error se repite dos veces.
	• Si cambiara la forma en la que, por ejemplo, reciben daño, tendríamos que reescribir recibir_danio dos veces.
	• ¿Y si hubiese diez zombis en lugar de dos? ¿Y si hubiese cien? ¡Cuántas veces habría que copiar y pegar!
Veamos una solución posible...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/266-programacion-con-objetos-clases-e-instancias-vivos> 

Ejercicio 5: Clases
Si tenemos más de un objeto que se comporta exactamente de la misma forma, lo que podemos hacer es generalizar ese comportamiento definiendo una clase. Por ejemplo, si tenemos dos celulares con el mismo saldo y ambos tienen las mismas funcionalidades, realizar_llamada! y cargar_saldo! :
module CelularDeMaría
  @saldo = 25
def self.realizar_llamada!
    @saldo -= 5
  end
def self.cargar_saldo!(pesos)
    @saldo += pesos
  end
end
module CelularDeLucrecia
  @saldo = 25
def self.realizar_llamada!
    @saldo -= 5
  end
def self.cargar_saldo!(pesos)
    @saldo += pesos
  end
end
Podemos generalizarlos en una clase Celular:
class Celular
  def initialize
    @saldo = 25
  end
def realizar_llamada!
    @saldo -= 5
  end
def cargar_saldo!(pesos)
    @saldo += pesos
  end
end
Veamos si se entiende: como Bouba y Kiki se comportan exactamente de la misma forma, generalizalos definiendo una clase Zombi que entienda los mismos cinco mensajes que ellos. Podés ver las definiciones de ambos zombis en la solapa Biblioteca.
 ¡Dame una pista!
	• Solución
	• Biblioteca
	• Consola
	
	1
	class Zombi
	2
	  def initialize
	3
	    @salud = 100
	4
	  end
	5
	  
	6
	 
	7
	  def sabe_correr?
	8
	    false
	9
	  end
	10
	​
	11
	  def gritar
	12
	    "¡agrrrg!"
	13
	  end
	14
	​
	15
	  def salud
	16
	    @salud
	17
	  end
	18
	​
	19
	  def recibir_danio!(puntos)
	20
	    @salud -= puntos * 2
	21
	    if @salud < 0
	22
	      @salud = 0
	23
	    end 
	24
	  end
	25
	​
	26
	  def sin_vida?
	27
	    @salud == 0
	28
	  end
	29
	  
	30
	end
Enviar
 ¡Muy bien! Tu solución pasó todas las pruebas
Las clases sólo nos sirven para generalizar objetos que tengan el mismo comportamiento: mismos métodos y mismos atributos. En nuestro caso, el código de ambos celulares y de ambos zombis es el mismo, por eso pudimos generalizarlo.
Si el código es parecido pero no puede ser generalizado para que sea el mismo, las clases no nos servirán. Al menos por ahora...

Desde <https://seprogramar.inti.gob.ar/inti/exercises/267-programacion-con-objetos-clases-e-instancias-clases> 


